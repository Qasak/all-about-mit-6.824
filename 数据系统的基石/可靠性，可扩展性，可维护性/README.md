## 可扩展性

以twitter为例

实现扇出（fan-out）——每个用户关注了很多人，也被很多人关注。

两种方式：

+ 发布推文时，只需将新推文插入全局推文集合即可。当一个用户请求自己的主页时间线 时，首先查找他关注的所有人，查询这些被关注用户发布的推文并按时间顺序合并。在 如图1-2所示的关系型数据库中，可以编写这样的查询：

  ```sql
  SELECT tweets.*, users.*
      FROM tweets
      JOIN users ON tweets.sender_id = users.id
      JOIN follows ON follows.followee_id = users.id
      WHERE follows.follower_id = current_user
  
  ```

  ![img](https://github.com/Qasak/distributed-system/blob/master/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%9F%B3/%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%8C%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%EF%BC%8C%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7/twitter0.png)

+ 为每个用户的主页时间线维护一个缓存，就像每个用户的推文收件箱。 当一个用户发布推文时，查找所有关注该用户的人，并将新的推文插入到每个主页时间线缓存中。 因此读取主页时间线的请求开销很小，因为结果已经提前计算好了。

![img](https://github.com/Qasak/distributed-system/blob/master/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%9F%B3/%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%8C%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%EF%BC%8C%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7/twitter1.png)

推特的第一个版本使用了方法1，但系统很难跟上主页时间线查询的负载。所以公司转向了方 法2，方法2的效果更好，因为发推频率比查询主页时间线的频率几乎低了两个数量级，所以 在这种情况下，最好在写入时做更多的工作，而在读取时做更少的工作。

然而方法2的缺点是，发推现在需要大量的额外工作。平均来说，一条推文会发往约75个关 注者，所以每秒4.6k的发推写入，变成了对主页时间线缓存每秒345k的写入。但这个平均值 隐藏了用户粉丝数差异巨大这一现实，一些用户有超过3000万的粉丝，这意味着一条推文就 可能会导致主页时间线缓存的3000万次写入！及时完成这种操作是一个巨大的挑战 —— 推特 尝试在5秒内向粉丝发送推文。

在推特的例子中，每个用户粉丝数的分布（可能按这些用户的发推频率来加权）是探讨可扩 展性的一个关键负载参数，因为它决定了扇出负载。你的应用程序可能具有非常不同的特 征，但可以采用相似的原则来考虑它的负载。 推特轶事的最终转折：现在已经稳健地实现了方法2，推特逐步转向了两种方法的混合。大多 数用户发的推文会被扇出写入其粉丝主页时间线缓存中。但是少数拥有海量粉丝的用户（即 名流）会被排除在外。当用户读取主页时间线时，分别地获取出该用户所关注的每位名流的 推文，再与用户的主页时间线缓存合并，如方法1所示。这种混合方法能始终如一地提供良好 性能。在第12章中我们将重新讨论这个例子，这在覆盖更多技术层面之后。

