## VMware FT FAQ

Q：在物理服务器上确保确定性执行比在虚拟机上更困难。为什么会这样？

A： 在VM上确保确定性更容易，因为管理程序(hypervisor)模拟和控制硬件的许多方面，这些方面可能在主执行和备份执行之间有所不同，例如中断传递的精确时间。

Q：什么是hypervisor?

A：hypervisor是虚拟机系统的一部分；它与虚拟机监视器（VMM）相同。hypervisor模拟一台计算机，一个客户操作系统（和应用程序）在模拟的计算机内执行。客户机在其中运行的仿真通常称为虚拟机。在本文中，主和备份是运行在虚拟机内的客户机，而FT是实现每个虚拟机的hypervisor的一部分。

***

Q： GFS和VMware FT都提供了容错功能。哪一个更好？

A： FT。

FT可以透明地将现有的容错技术添加到任何服务器上。FT提供了相当严格的一致性，并且对服务器和客户端是透明的。例如，您可以使用FT使现有的邮件服务器具有容错性。相比之下，GFS只为存储提供容错。因为GFS专门用于特定的简单服务（存储），所以它的复制比FT更高效。

例如，GFS不需要在所有副本上完全相同的指令处造成中断。GFS通常只是实现完整容错服务的较大系统的一部分。例如，VMware FT本身依赖于主备份共享的容错存储服务（图1中的共享磁盘），您可以使用类似GFS的东西来实现它（尽管在详细的层次上，GFS对于FT来说并不太合适）。

***

Q： 第3.4节的反弹缓冲(bounce buffers)如何帮助避免竞争？

A： 当网络数据包或请求的磁盘块到达主服务器并需要将其复制到主服务器的内存时，就会出现问题。如果没有FT，相关的硬件会在软件执行时将数据复制到内存中。来宾指令可以在DMA期间读取内存；根据确切的时间，来宾可能会看到或看不到DMA(Direct Memory Access，直接存储器访问) 的数据（这就是竞争）。如果主服务器和备份服务器都这样做，那将是糟糕的，由于时间上的细微差异，一个在DMA之后读取，另一个在DMA之前读取。如果那样的话，他们就会有分歧。

> FT强制这种争用磁盘操作在主磁盘和备份磁盘上以相同的顺序执行
>
> 因为更改页面上的MMU保护是一项昂贵的操作，所以我们选择使用反弹缓冲区

> 反弹缓冲区是一个临时缓冲区，其大小与磁盘操作访问的内存大小相同。磁盘读取操作被修改为将指定的数据读取到反弹缓冲区，并且数据仅在IO完成时复制到来宾内存。类似地，对于磁盘写入操作，要发送的数据首先被复制到反弹缓冲区，并且磁盘写入被修改为从反弹缓冲区写入数据。使用bounce缓冲区可以减慢磁盘操作，但是我们还没有看到它会导致任何明显的性能损失

FT通过在主或备份执行时不复制到来宾内存来避免这个问题。FT首先将网络包或磁盘块复制到主服务器无法访问的专用“反弹缓冲区”。当第一个拷贝完成时，FT hypervisor会中断主服务器，使其不执行。FT记录中断主设备的点（与任何中断一样）。然后FT将反弹缓冲区复制到主内存中，然后允许主进程继续执行。FT通过日志通道将数据发送到备份。备份的FT在主备份被中断的同一条指令下中断备份，在执行备份时将数据复制到备份的内存中，然后恢复备份。

其结果是，网络数据包或磁盘块在主服务器和备份服务器中出现的时间完全相同，因此无论它们何时读取内存，都可以看到相同的数据。

***

Q： 什么是“共享存储上的test-and-set操作”？

A： 系统使用一个网络磁盘服务器，由主服务器和备份服务器共享（图1中的“共享磁盘”）。网络磁盘服务器有一个“测试和设置服务”。测试和设置服务维护一个最初设置为false的标志。如果主服务器或备份服务器认为另一个服务器已经死了，因此它应该自己接管，它首先向磁盘服务器发送一个测试和设置操作。服务器大致执行以下代码：

```c
test-and-set() 
    acquire_lock()
    if flag == true:
		release_lock()
    	return false
    else:
		flag = true
  		release_lock()
    	return true
```

只有在test and set返回true时，主（或备份）才会接管（“goes live”）。

更高层次的观点是，如果主服务器和备份服务器彼此失去网络联系，我们只希望其中一个能够上线。危险的是，如果两者都恢复了，网络也失败了，两者都有可能存活并发展成脑裂。如果只有主服务器或备份服务器中的一个可以与磁盘服务器通信，那么该服务器将单独运行。但是如果两者都能和磁盘服务器对话呢？然后，网络磁盘服务器充当断开连接的角色；test and set只对第一次调用返回true。

***

Q： 遵循输出规则会损失多少性能？

A： 表2提供了一些见解。通过遵循输出规则，传输速率降低了，但不是很大。

***

Q： 如果应用程序调用随机数生成器怎么办？这不会在主备份上产生不同的结果，并导致执行出现分歧吗？

A： 主服务器和备用服务器将从它们的随机数生成器中获得相同的数字。所有随机性的来源都由hypervisor控制。例如，应用程序可以使用当前时间、硬件周期计数器或精确的中断时间作为随机性的来源。在这三种情况下，hypervisor都会截获主和备份上的相关指令，并确保它们产生相同的值。

***

Q： 创造者们如何确定他们捕捉到了所有可能的非决定论形式？

A： 我的猜测如下。作者在一家公司工作，在那里许多人都很了解VM管理程序、微处理器和来宾操作系统的内部结构，并且会意识到其中的许多缺陷。特别是对于VM-FT，作者利用了以前的a项目（确定性重播）的日志和回放支持，该项目必须已经处理了非确定性的来源。我假设确定性回放的设计者进行了广泛的测试，并获得了VM-FT作者使用的非确定性源的经验。

***

Q： 如果主服务器在向外部世界发送输出后发生故障，会发生什么情况？

A： 备份可能会在接管后重复输出，因此会生成两次。对于网络和磁盘I/O来说，这种复制不是问题。如果输出是网络数据包，则接收客户端的TCP软件将自动丢弃该复制。如果输出事件是磁盘I/O，则磁盘I/O是幂等的（两者都将相同的数据写入同一位置，并且没有中间的I/O）。

***

Q： 第3.4节讨论了发生故障时主服务器上未完成的磁盘I/O；它说“相反，我们在备份虚拟机的上线过程中重新发出挂起的I/O。”挂起的I/O位于/存储在何处，重新发布需要追溯到多长时间？

A： 本文讨论的是磁盘I/O，其中有一个日志条目表示I/O已启动，但没有表示完成的条目。这些是必须在备份上重新启动的I/O操作。当I/O完成时，I/O设备生成I/O完成中断。因此，如果日志中缺少I/O完成中断，则备份将重新启动I/O。如果日志中存在I/O完成中断，则无需重新启动I/O。

***

Q： 备份FT如何能够在备份指令流中的某个特定点（即在主指令上最初发生中断的同一条指令）传送中断？

A： 许多CPU都支持一个特性（“性能计数器”），该特性允许FT-VMM告诉CPU一些指令，并且CPU将在指令数达到该数量后中断到FT-VMM。

***

Q：这个系统安全吗？

A： 作者假设主服务器和备份服务器遵循协议，并且不是恶意的（例如，攻击者不会破坏hypervisor）。系统无法处理受损的虚拟机监控程序。另一方面，hypervisor可能可以防御恶意或有缺陷的客户操作系统和应用程序。

***

Q： 仅解决fail-stop故障是否合理？其他类型的故障是什么

A： 这是合理的，因为许多现实世界的故障本质上都是故障停机fail-stop，例如许多网络和电源故障。要做得更好，就需要处理那些看起来运行正常但实际计算结果不正确的计算机；在最坏的情况下，失败可能是恶意攻击者的结果。这种较大的非故障停机故障通常被称为“拜占庭式”。有很多方法可以处理拜占庭式的失败，我们将在本课程的最后讨论这些，但是6.824中的大部分都是关于fail-stop故障的。