## Go FAQ

Q： goroutines并行运行吗？能用它们来提高性能吗？

A： Go的goroutine与其他语言中的线程相同。Go运行时在所有可用内核上并行执行goroutines。如果核心比可运行goroutines少，那么运行时将在goroutine之间抢占时间共享核心。

***



Q： Go channel是怎么工作的？Go如何确保它们在许多可能的goroutine之间同步？

A：https://golang.org/src/runtime/chan.go

在高层，chan是一个拥有缓冲区和锁的结构。在通道上发送包括获取锁，等待（可能等待释放CPU）直到某个线程接收到，然后传递消息。接收包括获取锁并等待发送者。你可以用Go实现你自己的通道同步互斥以及同步状态.

***



Q： 我用一个通道来唤醒另一个goroutine，在通道上发送一个dummy bool。但是如果另一个goroutine已经在运行（因此没有在通道上接收），那么发送goroutine将阻塞。我该怎么办？

A： 尝试条件变量（Go's sync.Cond)而不是channel。条件变量可以很好地向goroutine发出警告，这些goroutine可能（或可能没有）正在等待某些内容。通道，因为它们是同步的，如果你不确定通道的另一端是否会有goroutine在等待，那么它们会很尴尬。

***

Q： 如何让goroutine等待来自多个不同通道中任何一个的输入？如果没有要读取的内容，尝试在任何一个通道上接收数据块，从而阻止goroutine检查其他通道。

A： 尝试为每个通道创建单独的goroutine，并将每个goroutine块放在其通道上。这并不总是可能的，但当它起作用时，往往是最简单的方法。

或者尝试Go‘s select

***

Q： 我们什么时候用sync.WaitGroup而不是通道？反之亦然？

A： WaitGroup是相当特殊的用途；它只在等待一堆活动完成时才有用。通道是更通用的；例如，可以通过通道传递值。你可以使用channels等待多个goroutine，尽管它比WaitGroup多了几行代码。

***

Q： 我需要我的代码每秒执行一次任务。最简单的方法是什么？

A： 创建一个goroutine专用于该定期任务。它应该有一个使用time.Sleep()暂停一秒钟，然后执行任务，然后循环到time.Sleep().

***

Q： 我们如何知道何时生成goroutine的开销超过了我们从它们获得的并发性？

A： 看情况而定！如果你的机器有16个内核，并且你正在寻找CPU并行性，那么应该有大约16个可执行goroutine。如果获取一个网页需要0.1秒的实时时间，并且您的网络能够每秒传输100个网页，那么您可能需要大约10个goroutine并发获取，以便使用所有网络容量。实验上，当您增加goroutine的数量时，在一段时间内您将看到吞吐量的增加，然后您将停止获得更多的吞吐量；从性能的角度来看，此时您有足够的goroutine。

***

Q： 如何创建一个通过互联网连接的Go通道？如何指定用于发送消息的协议？

A： Go频道只能在一个程序中工作；频道不能用于与其他程序或其他计算机对话。

看看Go的RPC软件包，它可以让你通过互联网与其他Go程序对话：

https://golang.org/pkg/net/rpc/

***

Q： 需要知道哪些重要/有用的特定于Go的并发模式？

A： 下面是一位Go专家关于这个主题的幻灯片：

https://talks.golang.org/2012/concurrency.slide

***

Q：切片是如何实现的？

A： 切片是一个对象，它包含一个指向数组的指针和一个指向该数组的开始和结束索引。这种安排允许多个片共享一个底层数组，每个片可能公开不同范围的数组元素。

 https://blog.golang.org/go-slices-usage-and-internals

我经常使用切片，从不使用数组。Go切片比Go数组更灵活，因为数组的大小是其类型的一部分，而以切片为参数的函数可以采用任意长度的切片。

***

Q： Go常用的调试工具有哪些？

A: fmt.Printf()

***

Q： 何时使用同步RPC调用是正确的，何时使用异步RPC调用是正确的？

A： 大多数代码在继续之前需要RPC应答；在这种情况下，使用同步RPC是有意义的。

但有时客户机希望启动多个并发RPC；在这种情况下，异步可能更好。或者客户机希望在等待RPC完成时执行其他工作，这可能是因为服务器距离较远（因此光速很高），或者是因为服务器可能无法访问，因此RPC会经历很长的超时时间。

我从未在Go中使用过异步RPC。当我想发送一个RPC但不必等待结果时，我创建一个goroutine，并让goroutine进行一个synchronous Call()。

***









